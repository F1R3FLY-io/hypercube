; Core of the ambient calculus
(theory
  (shapes (P R M N))
  (terms
    (new (-> N P) P)
    (0 P)
    (| P P P)
    (! P P)
    (amb N P P)
    (act M P)
    (in N P M)
    (out N P M)
    (open N P M))
  (interactions |)
  (rewrites
    (newr ((rho R))
      (new (lambda (x P) (src rho)))
      (new (lambda (x P) (tgt rho))))
    (par1 ((rho R) (Q P))
      (| (src rho) Q)
      (| (tgt rho) Q))
    (par2 ((rho1 R) (rho2 R))
      (| (src rho1) (src rho2))
      (| (tgt rho1) (tgt rho2)))
    (repl ((Q P))
      (! Q)
      (| Q (! Q)))
    (ambr ((n N) (rho R))
      (amb n (src rho))
      (amb n (tgt rho)))
    (inr ((m N) (n N) (Q1 P) (Q2 P) (Q3 P))
      (| (amb n (| (in m Q1) Q2)) (amb m Q3))
      (amb m (| (amb n (| Q1 Q2)) Q3)))
    (outr ((m N) (n N) (Q1 P) (Q2 P) (Q3 P))
      (amb m (| (amb n (| (out m Q1) Q2)) Q3))
      (| (amb n (| Q1 Q2)) (amb m Q3)))
    (openr ((m N) (Q1 P) (Q2 P))
      (| (open m Q1) (amb m Q2))
      (| Q1 Q2)))
  (equations
    (commutativity ((Q1 P) (Q2 P))
      (| Q1 Q2)
      (| Q2 Q1))
    (associativity ((Q1 P) (Q2 P) (Q3 P))
      (| (| Q1 Q2) Q3)
      (| Q1 (| Q2 Q3)))
    (unit ((Q P))
      (| 0 Q)
      Q)
    (newmn ((m N) (n N) (Q P))
      (new (lambda m (new (lambda n Q))))
      (new (lambda n (new (lambda m Q)))))
    (newmm ((m N) (Q P))
      (new (lambda m (new (lambda m Q))))
      (new (lambda m Q)))
    ; problems involving variable names: 
    ; par scope extrusion:     Q1 | νx.Q2 ≡ νx.(Q1 | Q2) if x not free in Q1
    ; ambient scope extrusion: m[νx. Q] = νx.m[Q] if x ≠ m
    ))
    
